=================Recursion===================

Subset Sum and Combination sums 

‚úÖ MASTER SUMMARY TABLE (WITH PROBLEM STATEMENT + CONSTRAINTS)

| Problem                                              | Problem Statement (Short)                                                                      	| Typical Constraints                 	  | Recurrence                                           	 | Recursive Time      	   | Recursive Space |
| -----------------------------------------------------| -------------------------------------------------------------------------------------------------- | --------------------------------------- | -------------------------------------------------------- | ----------------------- | ------------------- |
| Combination Sum I (unlimited use)                    | Find all combinations that sum to target; each number can be used unlimited times.                 | n ‚â§ 30, nums[i] ‚â§ 200, target ‚â§ 500     | `f(i, t) = f(i, t - a[i]) + f(i+1, t)`                   | Exponential (‚âà T‚Åø)      | O(T)                |
| Combination Sum II (use each once, avoid duplicates) | Find unique combinations where each number can be used at most once; input may contain duplicates. | n ‚â§ 100, nums[i] ‚â§ 100, target ‚â§ 30,000 | `f(i, t) = f(i+1, t-a[i]) + f(j, t)` ; j = next distinct | O(2‚Åø)                   | O(n)                |
| Combination Sum III (pick k numbers from 1‚Ä¶9)        | Choose exactly k numbers from {1..9} that sum to n.                                                | k ‚â§ 9, n ‚â§ 60                           | `f(i, k, t) = f(i+1,k-1,t-i)+f(i+1,k,t)`                 | O(2‚Åπ) ‚âà constant        | O(9)                |
| Combination Sum IV (order matters ‚Üí permutations)    | Count number of ordered sequences whose sum equals target.                                     	| n ‚â§ 200, target ‚â§ 1000                  | `dp[t] = Œ£ dp[t - a[i]]`                                 | Exponential (recursive) | O(T)                |
| Subset Sum (Decision)                                | Determine if any subset sums to target exactly.                                                    | n ‚â§ 200, sum ‚â§ 2000                     | `f(i, t)=f(i+1,t) OR f(i+1,t-a[i])`                      | O(2‚Åø)                   | O(n)                |
| Count Subsets With Sum                               | Count number of subsets that sum to target.                                                        | n ‚â§ 200, sum ‚â§ 2000                     | `count = f(i+1,t) + f(i+1,t-a[i])`                       | O(2‚Åø)                   | O(n)                |
| Partition Equal Subset Sum                           | Check if array can be split into 2 subsets of equal sum.                                           | n ‚â§ 200, sum ‚â§ 2000                     | Reduce to subset sum for T = total/2                     | O(2‚Åø)                   | O(n)                |
| Minimum Difference Partition                         | Split set into 2 subsets with minimum absolute difference.                                         | n ‚â§ 200, sum ‚â§ 2000                     | Compute reachable sums up to total/2                     | O(2‚Åø)                   | O(n)                |
| Target Sum (assign +/- signs)                        | Count ways to assign + or ‚Äì signs to reach target.                                                 | n ‚â§ 20, nums[i] ‚â§ 1000                  | Reduce to subset sum: `(S+T)/2`                          | O(2‚Åø)                   | O(n)                |
| Subset With Given Difference                         | Count subsets such that S1 ‚Äì S2 = diff                                                             | n ‚â§ 200, sum ‚â§ 2000                     | subset_sum = (total + diff)/2                            | O(2‚Åø)                   | O(n)                |



==============Permutations==============
Which Approach Should You Use?
| Approach                 | Best For               | Pros                | Cons                 |
| ------------------------ | ---------------------- | ------------------- | -------------------- |
| Swap Backtracking        | Low overhead           | No extra arrays     | Harder to reason     |
| Pick-unused Backtracking | Teaching / simplicity  | Clean logic         | More memory          |
| Next Permutation         | Sorted results         | Very efficient      | Only works if sorted |
| Unique-permutation       | Arrays with duplicates | Prevents duplicates | More branching logic |



================N Queens=============
üéØ N-Queens Problem ‚Äì Core Idea

Goal:
Place N queens on an N √ó N chessboard such that:
	No two queens share the same row
	No two queens share the same column
	No two queens share the same diagonal
	
üß† How to Solve N-Queens (Backtracking)

We place one queen per row:

Start at row = 0
Try placing a queen in each column
Check if placing a queen is safe
If safe ‚Üí place queen and recursively place for next row
If no column works ‚Üí backtrack (remove queen)

This is depth-first search with pruning using safety checks.


====
Same Col 
Main Diagonal : [ R - C Value is same ]
Anti Diagonal : [ R+C Value is same ] 

cols          ‚Üí columns already occupied
diag1 (r-c)   ‚Üí main diagonals occupied
diag2 (r+c)   ‚Üí anti-diagonals occupied


======Distinct N queens Solutions=====
To count only distinct solutions:

Approach:
	Solve N-Queens normally and store the positions of queens per row (e.g., queen_pos[row] = column).

	For each solution, generate all 8 symmetric transformations:
		Rotate 90¬∞, 180¬∞, 270¬∞
		Reflect horizontally, vertically, or diagonally
	Store the canonical form (lexicographically smallest among these 8 forms) in a set.
	Count the number of unique canonical forms ‚Üí this gives distinct solutions. 