============Python Modules Internals=====

typedef struct {
    PyObject_HEAD

    int co_argcount;        // positional args
    int co_posonlyargcount;
    int co_kwonlyargcount;
    int co_nlocals;         // local variables count
    int co_stacksize;       // required stack size
    int co_flags;           // generator, coroutine, etc.

    PyObject *co_code;      // BYTECODE (bytes object)
    PyObject *co_consts;    // literals used (numbers, strings, code objects)
    PyObject *co_names;     // global names used
    PyObject *co_varnames;  // local variable names
    PyObject *co_freevars;  // closure vars
    PyObject *co_cellvars;  // vars shared with inner functions

    PyObject *co_filename;  // source filename
    PyObject *co_name;      // function name
    int co_firstlineno;
    PyObject *co_lnotab;    // line number mapping
} PyCodeObject;


What uses PyCodeObject?
	âœ” Python functions
	âœ” Lambdas
	âœ” Class bodies
	âœ” Modules (.py files)
	âœ” Generator functions
	âœ” Async functions
	

Where is PyCodeObject stored?
	â€¢ Function object: func.__code__
	â€¢ Module object: module.__dict__['__loader__'] â†’ code
	â€¢ Nested functions: inside co_consts
	â€¢ Cached in .pyc files (marshaled)
	
How is PyCodeObject executed?

	PyCodeObject
	   â†“
	PyFrameObject (runtime execution context)
	   â†“
	Python Virtual Machine (eval loop)


Execution flow:
	code â†’ frame â†’ eval loop â†’ bytecode instructions


================================================================
2ï¸ PyCFunctionObject
================================================================
Represents a BUILT-IN FUNCTION implemented in C
NO Python bytecode
NO PyCodeObject


typedef struct {
    PyObject_HEAD

    PyMethodDef *m_ml;   // C function pointer + metadata
    PyObject *m_self;   // bound object (for methods)
    PyObject *m_module; // owning module
} PyCFunctionObject;



typedef struct {
    const char *ml_name;
    PyCFunction ml_meth;   // actual C function pointer
    int ml_flags;         // calling convention
    const char *ml_doc;
} PyMethodDef;


What uses PyCFunctionObject?
	âœ” Built-in modules (sys, math, time)
	âœ” Built-in functions (len, print)
	âœ” Built-in methods (list.append)
	âœ” C-extension modules
	
Where is PyCFunctionObject stored?
	â€¢ Module namespace: module.__dict__
	â€¢ Type method table: list.__dict__['append']
	â€¢ sys.builtin_module_names

Internally:
	len â†’ PyCFunctionObject â†’ C function pointer
	
How is PyCFunctionObject executed?

	Python VM sees a CALL opcode
	â†“
	Detects PyCFunctionObject
	â†“
	Direct C function call
	â†“
	Return PyObject*
	
================================================================
3ï¸ KEY DIFFERENCES (INTERVIEW CRITICAL)
================================================================
| Aspect       | PyCodeObject       | PyCFunctionObject       |
| ------------ | ------------------ | ----------------------- |
| Represents   | Python bytecode    | C function              |
| Used by      | Python code        | Built-in / C extensions |
| Has bytecode | âœ” Yes              | âŒ No                    |
| Executed by  | Python VM          | Direct C call           |
| Stored in    | Function, module   | Method table, module    |
| Performance  | Slower             | Faster                  |
| Inspectable  | âœ” Yes (`__code__`) | âŒ No                    |



Built-in modules
	sys, math, time
	â†’ PyCFunctionObject

Standard library (.py)
	json, collections, asyncio
	â†’ PyCodeObject

Mixed modules
	math.py + _math.c
	â†’ BOTH
	
Importing Python module
	1. Read .py
	2. Compile â†’ PyCodeObject
	3. Create module object
	4. Execute code object in module namespace
	
Importing C-extension module
	1. Load .so / .pyd
	2. Register PyMethodDef table
	3. Create PyCFunctionObjects
	
================================================================
6ï¸ WHY PyCodeObject â‰  PyFunctionObject
================================================================
	csharp
	Copy code
	PyCodeObject  â†’ static, immutable, reusable
	PyFunctionObject â†’ runtime object with globals, defaults, closures
	
	
============================
Built-in modules:
	- Already inside Python
	- Faster
	- No installation

C extension modules:
	- Use CPython C API
	- Extremely fast
	- Used for math, crypto, system calls

Pure Python modules:
	- Easier to read and modify
	- Slightly slower
	- Used for structure and abstraction


How Python Decides What Type a Module Is

When you write: import module_name

Python checks:
	1. sys.builtin_module_names
	2. Frozen modules
	3. Standard library paths
	4. Site-packages (pip)

Type                      | Written In | Compiled | Speed     | Example
---------------------------------------------------------------------------
Core Built-in              | C          | Yes      | Fastest   | sys
Built-in C Extension       | C          | Yes      | Very Fast | math
Standard Library (Python)  | Python     | No       | Moderate  | os
Mixed Modules              | Python + C | Partial  | Fast      | json
Third-Party Modules        | Python/C   | Optional | Varies    | numpy


import sys
import math
import os


Python Modules
â”‚
â”œâ”€â”€ Built-in Modules
â”‚   â”œâ”€â”€ Core Built-in (Interpreter Internal)
â”‚   â”œâ”€â”€ Built-in C Extension Modules
â”‚   â””â”€â”€ Standard Library (Python / Mixed)
â”‚
â””â”€â”€ External (Third-Party) Modules
    â””â”€â”€ Installed via pip


1. Core Built-in Modules (Interpreter Internal)
These modules are:
	- Compiled directly into the Python executable
	- Always available
	- Loaded instantly
	- Implemented entirely in C
	
	âœ” Part of interpreter binary
	âœ” Cannot be removed
	âœ” Extremely fast
	âœ” No .py file exists

| Module   | Why it belongs here                                |
| -------- | -------------------------------------------------- |
| builtins | Defines all built-in names (int, list, print, len) |
| sys      | Holds interpreter state (argv, path, modules)      |
| gc       | Direct access to garbage collector                 |
| _imp     | Core import machinery                              |
| __main__ | Entry module for execution                         |

Python executable
â””â”€â”€ Core interpreter state
    â”œâ”€â”€ builtins
    â”œâ”€â”€ sys
    â”œâ”€â”€ gc
    â””â”€â”€ _imp

	
2. Built-in C Extension Modules (MOST IMPORTANT CATEGORY)
These modules:
	- Are written in C
	- Compiled as shared libraries (.so / .pyd)
	- Exposed to Python via CPython API
	
	âœ” Written in C
	âœ” Very fast
	âœ” Loaded dynamically
	âœ” No Python source code
| Module       | Reason                          |
| ------------ | ------------------------------- |
| time         | OS-level clock access           |
| math         | Hardware-accelerated math       |
| array        | Compact typed memory            |
| marshal      | Internal bytecode serialization |
| _thread      | Low-level threads               |
| _io          | Core I/O engine                 |
| _signal      | OS signal handling              |
| _weakref     | Weak reference support          |
| _collections | C backend for collections       |
| _functools   | C backend (lru_cache, reduce)   |
| _operator    | Operator functions              |
| _heapq       | Heap implementation             |
| _bisect      | Binary search                   |
| _json        | JSON C parser                   |
| _pickle      | Pickle C serializer             |

Leading underscore (_) â†’ usually internal C backend

Why they exist?
	- Performance
	- Low-level system access
	- Memory efficiency
math.sqrt â†’ C function â†’ CPU instruction


3. Standard Library Modules (Pure Python)
These modules:
	- Written in Python (.py files)
	- Shipped with Python
	- Can import other modules

Characteristics
	âœ” Human-readable Python code
	âœ” Slightly slower than C modules
	âœ” Easy to extend and debug

| Module      | Reason                      |
| ----------- | --------------------------- |
| pathlib     | High-level path abstraction |
| argparse    | CLI parsing                 |
| logging     | Logging framework           |
| inspect     | Runtime introspection       |
| traceback   | Stack trace formatting      |
| contextlib  | Context manager utilities   |
| dataclasses | Class decorators            |
| typing      | Type hint system            |
| unittest    | Testing framework           |
| doctest     | Documentation testing       |
| glob        | File pattern matching       |
| tempfile    | Temp file utilities         |
| shutil      | High-level file ops         |
| csv         | CSV handling                |

Lib/
â”œâ”€â”€ argparse.py
â”œâ”€â”€ logging/__init__.py
â”œâ”€â”€ typing.py
â””â”€â”€ dataclasses.py

	
4. Mixed Modules (Python + C)
Some modules use:
	- Python code for logic
	- C extensions for performance-critical parts

Why mixed?
	Python for readability
	C for speed
	
| Module          | Python Layer   | C Backend             |
| --------------- | -------------- | --------------------- |
| os              | os.py          | posix / nt            |
| collections     | collections.py | _collections          |
| functools       | functools.py   | _functools            |
| itertools       | Python API     | C core                |
| json            | json.py        | _json                 |
| pickle          | pickle.py      | _pickle               |
| re              | re.py          | _sre                  |
| datetime        | Python API     | C datetime            |
| random          | random.py      | C helpers             |
| subprocess      | subprocess.py  | OS syscalls           |
| threading       | threading.py   | _thread               |
| multiprocessing | Python logic   | OS + C                |
| asyncio         | Python logic   | event loop primitives |
| sqlite3         | Python API     | SQLite C              |
| hashlib         | Python API     | OpenSSL C             |

	
=========Internals of Python Import System==========
modules, sys.modules, loaders, PyCodeObject, PyCFunctionObject, and caching.

Iâ€™ll walk through this exactly in the order CPython does it, first for import math, 
then for re-import, then what is cached and why, and finally some important corner cases


Step 0: What import math really means
	it is not a simple file read.
	It triggers the import machinery implemented mainly in:

	importlib/_bootstrap.py
	importlib/_bootstrap_external.py
	
	At C-level, it starts from:
	PyImport_ImportModuleLevelObject()


High-level picture of Python import system
	import statement
	   â†“
	import machinery (importlib)
	   â†“
	sys.modules  (CACHE)
	   â†“
	finder â†’ loader
	   â†“
	module object
	
import X
â”‚
â”œâ”€â”€ BuiltinImporter?
â”‚      â””â”€â”€ yes â†’ load
â”‚
â”œâ”€â”€ FrozenImporter?
â”‚      â””â”€â”€ yes â†’ load
â”‚
â”œâ”€â”€ PathFinder?
â”‚      â””â”€â”€ yes â†’ search sys.path
â”‚
â””â”€â”€ ImportError

Importer          | Loads What                     | Example Modules
-------------------------------------------------------------------
BuiltinImporter   | Interpreter built-ins           | sys, builtins
FrozenImporter    | Embedded frozen bytecode        | importlib._bootstrap
PathFinder        | Files on sys.path               | os, json, user modules

BuiltinImporter â†’ No file
FrozenImporter  â†’ No file
PathFinder      â†’ Needs filesystem

ðŸ”¹ Built-in Mental model
python.exe
â””â”€â”€ Built-in symbol table
    â”œâ”€â”€ sys
    â”œâ”€â”€ builtins
    â””â”€â”€ gc
ðŸ”¹ Importer used
BuiltinImporter

2ï¸. FrozenImporter
ðŸ”¹ What it loads
	Frozen modules (Python code embedded into the interpreter binary)
	python.exe
	â””â”€â”€ Embedded bytecode
		â”œâ”€â”€ importlib._bootstrap
		â””â”€â”€ importlib._bootstrap_external

3ï¸. PathFinder
ðŸ”¹ What it loads
	All file-based modules found via sys.path
	
Characteristics
	Searches directories listed in sys.path
	Delegates loading to loaders:
		SourceFileLoader
		ExtensionFileLoader
		SourcelessFileLoader
sys.path
â”œâ”€â”€ stdlib/
â”‚   â”œâ”€â”€ os.py
â”‚   â”œâ”€â”€ json/
â”‚   â””â”€â”€ collections/
â”œâ”€â”€ site-packages/
â””â”€â”€ project/




=========================================
SCRIPT: import json
|
v
1) sys.modules?  --> not found
|
v
2) Locate module (search path)
   - .py file (standard library)
|
v
3) Compile to PyCodeObject
|
v
4) Create PyModuleObject
   - md_dict initialized
|
v
5) Execute PyCodeObject in md_dict
   - functions: PyFunctionObject
   - classes: PyTypeObject
|
v
6) Store module object in sys.modules
|
v
7) Bind name in local/global namespace
   script_globals['json'] = PyModuleObject
   
SCRIPT: import json (again)
|
v
1) sys.modules? --> Found!
|
v
2) Bind name in local/global namespace
   No re-execution, no new compilation

Key Notes / Corner Cases
	Built-in / frozen â†’ never compiled, already in interpreter memory.
	C extensions â†’ module namespace holds PyCFunctionObjects.
	Python module â†’ executed PyCodeObject â†’ md_dict stores PyFunctionObjects, classes, variables.
	sys.modules is the central cache for all module types.
	Circular imports â†’ partially initialized PyModuleObjects in sys.modules.



=======Step By Step Import Process=====

Suppose your code:
	import sys        # built-in
	import math       # C extension
	import json       # standard library

Step 1: Check sys.modules (module cache)
	Python keeps a dictionary of loaded modules:
		sys.modules
		# key: module name
		# value: module object (PyModuleObject)
	If module exists â†’ reuse
	Otherwise â†’ continue loading.

